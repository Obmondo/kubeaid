# Examples for adding git repo
#        - type: git
#          url: https://github.com/someuser/k8s-repo.git
#          passwordSecret:
#            name: argo-cd-someuser-github
#            key: password
#          usernameSecret:
#            name: argo-cd-someuser-github
#            key: username

argo-cd:
  global:
    revisionHistoryLimit: 2
  # to make this chart work with helm 3 - it does still install CRDs
  installCRDs: false
  # find latest tag here: https://github.com/argoproj/argo-helm/blob/master/charts/argo-cd/Chart.yaml (AppVersion)
  dex:
    enabled: false
    resources:
      limits:
        memory: 64Mi
      requests:
        cpu: 1m
        memory: 32Mi
  repoServer:
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 10m
        memory: 128Mi
    replicas: 1
    autoscaling:
      enabled: false
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
  server:
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 5m
        memory: 128Mi
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
    config:
      resource.exclusions: |
        - apiGroups:
          - "velero.io"
          kinds:
          - "Backup"
          clusters:
          - "*"
  controller:
    resources:
      limits:
        memory: 1024Mi
      requests:
        cpu: 250m
        memory: 512Mi
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true
  redis:
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 2m
        memory: 64Mi
    metrics:
      enabled: true
      image:
        repository: bitnami/redis-exporter
      serviceMonitor:
        enabled: true
  notifications:
    resources:
      limits:
        memory: 256Mi
      requests:
        cpu: 2m
        memory: 64Mi
    metrics:
      enabled: true
      serviceMonitor:
        enabled: true

  configs:
    cm:
      # For ArgoCD-CrossPlane integration, we need to use annotation based application resource
      # tracking.
      #
      # You ask why? Let me explain :
      #
      # Suppose, we define an XR claim (which is namespace scoped) in our git repository. The
      # 'infrastructure' ArgoCD App is tracking this XR Claim.
      # The XR Claim will dynamically generate an XR (which is cluster scoped). And this XR will
      # derive the 'argocd.argoproj.io/instance' label from its parent XR Claim.
      #
      # So, the situation is : we have a dynamically generated XR, not defined in git, but being
      # tracked by ArgoCD, because of that derived label.
      # This will cause the 'infrastructure' ArgoCD App to be always out of sync. Additionally,
      # if someone syncs the 'infrastructure' ArgoCD App, with pruning enabled, then ArgoCD will
      # delete those XRs.
      application.resourceTrackingMethod: annotation

kubeaidAppProject:
  enabled: true

blackbox:
  probe: true
